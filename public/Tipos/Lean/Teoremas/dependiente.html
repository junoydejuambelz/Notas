<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-22 Mon 08:14 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TeorÃ­a de tipos dependientes</title>
<meta name="generator" content="Org Mode" />
<link rel='stylesheet' href='/style.css' />
<script defer src='/navbar.js'></script>
<script>
  window.MathJax = {
  tex: {
  inlineMath: [['$', '$'], ['\\(', '\\)']],
  displayMath: [['$$', '$$'], ['\\[', '\\]']],
  processEscapes: true,
  processEnvironments: true,
  packages: {'[+]': ['ams', 'newcommand', 'configmacros', 'action', 'cancel', 'color', 'enclose', 'mhchem', 'unicode', 'verb']}
  },
  loader: {
  load: ['[tex]/newcommand', '[tex]/configmacros', '[tex]/action', '[tex]/cancel', '[tex]/color', '[tex]/enclose', '[tex]/mhchem', '[tex]/unicode', '[tex]/verb']
  },
  options: {
  skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
  };
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
  <script>
  MathJax.startup.defaultReady();
  </script>
</head>
<body>
<div id="preamble" class="status">
<nav class="navbar">
        <div class="navbar-brand">
            <a href="/index.html">ğŸ  Home</a>
        </div>
        <div class="navbar-menu">
                <div class="navbar-item dropdown">
                        <a href="#" class="dropbtn">ğŸ–¥ï¸ ComputaciÃ³n</a>
                        <div class="dropdown-content">
                                <a href="/Computacion/index.html">ğŸ“‹ Resumen</a>
                                <div class="dropdown-submenu">
                                        <a href="#" class="submenu-btn">âš™ï¸ Algoritmos</a>
                                        <div class="submenu-content">
                                                <a href="/Computacion/Algoritmos/index.html">ğŸ“‹ Resumen</a>
                                                <a href="/Computacion/Algoritmos/pensamiento.html">ğŸ§  Pensamiento algorÃ­tmico</a>
                                        </div>
                                </div>
                        </div>
                </div>
                <div class="navbar-item dropdown">
                        <a href="#" class="dropbtn">ğŸ¤– AI</a>
                        <div class="dropdown-content">
                                <a href="/AI/index.html">ğŸ“‹ Resumen</a>
                                <div class="dropdown-submenu">
                                        <a href="#" class="submenu-btn">ğŸ“š CS229</a>
                                        <div class="submenu-content">
                                                <a href="/AI/CS229/index.html">ğŸ“‹ Resumen</a>
                                                <a href="/AI/CS229/AprendizajeSupervisado/aprendizaje_supervisado.html">ğŸ¯ Aprendizaje Supervisado</a>
                                                <a href="/AI/CS229/AprendizajeSupervisado/regresion_lineal.html">ğŸ“ˆ RegresiÃ³n Lineal</a>
                                        </div>
                                </div>
                                <div class="dropdown-submenu">
                                        <a href="#" class="submenu-btn">ğŸ—ï¸ DataCamp</a>
                                        <div class="submenu-content">
                                                <a href="/AI/DataCamp/index.html">ğŸ“‹ Resumen</a>
                                                <a href="/AI/DataCamp/desglosando_el_transformer.html">ğŸ” Desglosando el Transformer</a>
                                                <a href="/AI/DataCamp/embedding_y_codificacion_posicional.html">ğŸ”— Embedding y CodificaciÃ³n Posicional</a>
                                        </div>
                                </div>
                        </div>
                </div>
                <div class="navbar-item dropdown">
                        <a href="#" class="dropbtn">ğŸ”¤ Tipos</a>
                        <div class="dropdown-content">

                                <div class="dropdown-submenu">
                                        <a href="#" class="submenu-btn">âœï¸ Pruebas y tipos</a>
                                        <div class="submenu-content">
                                                <a href="/Tipos/ProofsAndTypes/index.html">ğŸ“‹ Resumen </a>
                                                <a href="/Tipos/ProofsAndTypes/sentido.html">ğŸ§  Sentido, denotaciÃ³n y semÃ¡ntica</a>
                                        </div>
                                </div>

                                <div class="dropdown-submenu">
                                        <a href="#" class="submenu-btn">ğŸ”¬ HoTT</a>
                                        <div class="submenu-content">
                                                <div class="dropdown-submenu">
                                                        <a href="#" class="submenu-btn">ğŸ« HoTT (Carnegie Mellon)</a>
                                                        <div class="submenu-content">
                                                                <a href="/Tipos/HoTT/Curso/index.html">ğŸ“‹ Resumen</a>
                                                                <a href="/Tipos/HoTT/Curso/introduccion.html">ğŸš€ IntroducciÃ³n</a>
                                                                <a href="/Tipos/HoTT/Curso/juicios.html">âš–ï¸ Juicios</a>
                                                                <a href="/Tipos/HoTT/Curso/transitividad.html">ğŸ”› Transitividad </a>
                                                                <a href="/Tipos/HoTT/Curso/exponenciales.html">ğŸ—¼ Exponenciales</a>
                                                                <a href="/Tipos/HoTT/Curso/igualdad.html">ğŸŸ° Igualdad</a>
                                                        </div>
                                                </div>

                                                <div class="dropdown-submenu">
                                                        <a href="#" class="submenu-btn">ğŸ“š IntroducciÃ³n a HoTT (Rijke)</a>
                                                        <div class="submenu-content">
                                                                <a href="/Tipos/HoTT/Rijke/index.html">ğŸ“‹ Resumen </a>
                                                                <a href="/Tipos/HoTT/Rijke/intro.html">ğŸ“– IntroducciÃ³n </a>
                                                        </div>
                                                </div>
                                        </div>
                                </div>

                                <div class="dropdown-submenu">
                                        <a href="#" class="submenu-btn">ğŸ–¥ï¸ Lean</a>
                                        <div class="submenu-content">
                                                <a href="/Tipos/Lean/index.html">ğŸ“‹ Resumen </a>
                                        </div>
                                </div>
                        </div>
                </div>
        </div>
  </nav>
</div>
<div id="content" class="content">
<h1 class="title">TeorÃ­a de tipos dependientes</h1>
<p>
La teorÃ­a de tipos dependiente es un lenguaje poderoso y expresivo, que permite expresar
afirmaciones matemÃ¡ticas complejas, escribir especificaciones de software y hardware y
razonar sobre ambas de manera natural y uniforme. Lean se basa en una versiÃ³n de la teorÃ­a
de tipos dependiente llamada el <b>CÃ¡lculo de construcciones</b>, con una jerarquÃ­a numerable de
universos y tipos inductivos.
</p>
<div id="outline-container-orgd3a0918" class="outline-2">
<h2 id="orgd3a0918">TeorÃ­a de tipos simple</h2>
<div class="outline-text-2" id="text-orgd3a0918">
<p>
La "teorÃ­a de tipos" adquiere su nombre del hecho de que cada expresiÃ³n tiene un tipo asociado.
Por ejemplo, en un contexto, <code>x + 0</code> puede denotar un nÃºmero natural y <code>f</code> puede denotar una funciÃ³n
sobre los nÃºmeros naturales. En Lean, un nÃºmero natural es un entero sin signo con precisiÃ³n
arbitraria.
AquÃ­ hay unos ejemplos de objetos y cÃ³mo podemos checar sus tipos.
</p>

<div class="org-src-container">
<pre class="src src-lean4">def m: Nat := 1 -- m es un nÃºmero natural
def n: Nat := 0
def b1: Bool := true -- b1 es un booleano
def b2: Bool := false
</pre>
</div>

<p>
Podemos verificar sus tipos
</p>
<div class="org-src-container">
<pre class="src src-lean4">#check m
#check n
#check n + 0
#check b1
#check b1 &amp;&amp; b2
#check b1 || b2
#check true
</pre>
</div>

<pre class="example">
m : Nat
n : Nat
n + 0 : Nat
b1 : Bool
b1 &amp;&amp; b2 : Bool
b1 || b2 : Bool
Bool.true : Bool
</pre>



<p>
TambiÃ©n podemos evaluar expresiones
</p>
<div class="org-src-container">
<pre class="src src-lean4">#eval 5 +4
#eval m + 2
#eval b1 &amp;&amp; b2
</pre>
</div>

<pre class="example">
9
3
false
</pre>



<p>
La palabra clave <code>def</code> declara nuevos sÃ­mbolos constantes en el ambiente. En el ejemplo de arriba,
<code>def m: Nat := 1</code> define una nueva constante <code>m</code> de tipo <code>Nat</code> cuyo valor es 1. El comando <code>#check</code>
le pide a Lean que reporte sus tipos; en lean, los comandos auxiliares que hacen preguntas al
sistema para obtener informaciÃ³n generalmente comienzan con <code>#</code>. El comando <code>#eval</code> le pide a Lean
que evalÃºe una expresiÃ³n dada.
</p>

<p>
Lo que hace que la teorÃ­a de tipos simple sea poderosa es que podemos crear nuevos tipos a
partir de otros. Por ejemplo, si \(a\) y \(b\) son tipos, \(a \to b\) denota el tipo de funciones
de \(a\) en \(b\), y \(a \times b\) denota el tipo de los pares que consisten de un elemento de
\(a\) emparejado con un elemento de \(b\), tambiÃ©n conocido como <b>producto Cartesiano</b>.
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check Nat â†’ Nat
#check Nat -&gt; Nat

#check Nat \times Nat
#check Prod Nat Nat

#check Nat â†’ Nat â†’ Nat
#check Nat â†’ (Nat â†’ Nat)

#check Nat \times Nat â†’ Nat
#check (Nat â†’ Nat) â†’ Nat

#check Nat.succ
#check (0, 1)

#check Nat.succ 2
#check Nat.add 3

#check Nat.add 5 2
#check (5, 9).1
#check (5, 9).2

#eval Nat.succ 2
#eval Nat.add 5 2
#eval (5, 9).1
#eval (5, 9).2
</pre>
</div>

<pre class="example" id="orgc31ee95">
Nat â†’ Nat : Type
Nat â†’ Nat : Type
Nat Ã— Nat : Type
Nat Ã— Nat : Type
Nat â†’ Nat â†’ Nat : Type
Nat â†’ Nat â†’ Nat : Type
Nat Ã— Nat â†’ Nat : Type
(Nat â†’ Nat) â†’ Nat : Type
Nat.succ (n : Nat) : Nat
(0, 1) : Nat Ã— Nat
Nat.succ 2 : Nat
Nat.add 3 : Nat â†’ Nat
Nat.add 5 2 : Nat
(5, 9).fst : Nat
(5, 9).snd : Nat
3
7
5
9
</pre>
</div>
</div>
<div id="outline-container-orgf88123e" class="outline-2">
<h2 id="orgf88123e">Tipos como objetos</h2>
<div class="outline-text-2" id="text-orgf88123e">
<p>
Una forma en la que la teorÃ­a de tipos de Lean extiende la teorÃ­a de tipos simple es que los
tipos mismos -como <code>Nat</code> o <code>Bool</code>- son entidades de primera clase, es decir, son objetos. Para
que esto sea posible, cada uno de ellos debe tambiÃ©n tener un tipo.
</p>
<div class="org-src-container">
<pre class="src src-lean4">#check Nat
#check Bool
#check Nat â†’ Bool
#check Nat \times Bool
#check Nat â†’ Nat
#check Nat \times Nat â†’ Nat
</pre>
</div>

<pre class="example">
Nat : Type
Bool : Type
Nat â†’ Bool : Type
Nat Ã— Bool : Type
Nat â†’ Nat : Type
Nat Ã— Nat â†’ Nat : Type
</pre>


<p>
Podemos ver que cada una de estas expresiones son un objeto de tipos <code>Type</code>. TambiÃ©n podemos
declarar constantes para tipos
</p>
<div class="org-src-container">
<pre class="src src-lean4">def Î±: Type := Nat
def Î²: Type := Bool
def F: Type â†’ Type := List
def G: Type â†’ Type â†’ Type := Prod
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lean4">#check Î±
#check F Î±
#check F Nat
#check G Î±
#check G Î± Î²
#check G Î± Nat
</pre>
</div>

<pre class="example">
Î± : Type
F Î± : Type
F Nat : Type
G Î± : Type â†’ Type
G Î± Î² : Type
G Î± Nat : Type
</pre>


<p>
Como el ejemplo anterior sugiere, ya hemos visto una funciÃ³n de tipo <code>Type â†’ Type â†’ Type</code>, el
producto cartesiano <code>Prod</code>:
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check Prod Î± Î²
#check Î± \times Î²
</pre>
</div>

<pre class="example">
Î± Ã— Î² : Type
Î± Ã— Î² : Type
</pre>


<p>
AquÃ­ hay otro ejemplo: dado un tipo <code>Î±</code>, el tipo <code>List Î±</code> denota el tipo de listas de elementos de
tipo <code>Î±</code>.
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check List Î±
#check List Nat
</pre>
</div>

<pre class="example">
List Î± : Type
List Nat : Type
</pre>


<p>
Dado que cada expresiÃ³n en Lean tiene un tipo, es natural preguntarse: Â¿quÃ© tipo tiene
<code>Type</code>?
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check Type
</pre>
</div>

<pre class="example">
Type : Type 1
</pre>


<p>
Lean tiene una jerarquÃ­a de tipos:
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check Type
#check Type 1
#check Type 2
#check Type 3
#check Type 4
</pre>
</div>

<pre class="example">
Type : Type 1
Type 1 : Type 2
Type 2 : Type 3
Type 3 : Type 4
Type 4 : Type 5
</pre>


<p>
Hay que pensar en  <code>Type 0</code> como un universo de tipos "pequeÃ±os" u ordinarios. <code>Type 1</code> es entonces
un universo mÃ¡s grande de tipos, que contiene a <code>Type 0</code> como elemento. La lista es infinita,
hay un <code>Type n</code> para cada nÃºmero natural <code>n</code>. <code>Type</code> es una abreviatura para <code>Type 0</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">sort</td>
<td class="org-left">Prop (Sort 0)</td>
<td class="org-left">Type (Sort 1)</td>
<td class="org-left">Type 1 (Sort 2)</td>
<td class="org-left">Type 2 (Sort 3)</td>
<td class="org-left">&#x2026;</td>
</tr>

<tr>
<td class="org-left">type</td>
<td class="org-left">True</td>
<td class="org-left">Bool</td>
<td class="org-left">Nat &rarr; Type</td>
<td class="org-left">Type &rarr; Type 1</td>
<td class="org-left">&#x2026;</td>
</tr>

<tr>
<td class="org-left">term</td>
<td class="org-left">True.intro</td>
<td class="org-left">true</td>
<td class="org-left">fun n =&gt; Fin n</td>
<td class="org-left">fun (_ : Type) =&gt; Type</td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>

<p>
Sin embargo, algunas operaciones deben ser polimorfas sobre universos de tipos. Por ejemplo, <code>List Î±</code> debe
hacer sentido para cualquier tipo <code>Î±</code>, sin importar el universo de tipos en el que vive. Esto explica la
signature de la funciÃ³n <code>List</code>:
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check List
</pre>
</div>

<pre class="example">
List.{u} (Î± : Type u) : Type u
</pre>


<p>
AquÃ­ <code>u</code> es una variable que varÃ­a sobre todos los niveles de tipos. La salida del comando <code>#check</code> significa
que cuando <code>Î±</code> tiene tipo <code>Type u</code>, <code>List Î±</code> tambiÃ©n tiene tipo <code>Type u</code>. La funciÃ³n <code>Prod</code> tambiÃ©n es polimorfa.
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check Prod
</pre>
</div>

<pre class="example">
Prod.{u, v} (Î± : Type u) (Î² : Type v) : Type (max u v)
</pre>


<p>
Para definir constantes polimorfas, Lean permite declarar el universo de las variables explÃ­citamente
mediante el comando <code>universe</code>:
</p>

<div class="org-src-container">
<pre class="src src-lean4">universe u

def F (Î±: Type u): Type u := Prod Î± Î±

#check F
</pre>
</div>

<pre class="example">
F.{u} (Î± : Type u) : Type u
</pre>


<p>
Podemos esquivar el comando <code>universe</code> dando los parÃ¡metros de universo cuando definimos <code>F</code>:
</p>

<div class="org-src-container">
<pre class="src src-lean4">def F.{u} (Î±: Type u): Type u := Prod Î± Î±

#check F
</pre>
</div>

<pre class="example">
F.{u} (Î± : Type u) : Type u
</pre>
</div>
</div>
<div id="outline-container-orgc8017ec" class="outline-2">
<h2 id="orgc8017ec">AbstracciÃ³n de funciones y evaluaciÃ³n</h2>
<div class="outline-text-2" id="text-orgc8017ec">
<p>
Lean da la palabra clave <code>fun</code> (o <code>Î»</code>) para crear funciones a partir de una expresiÃ³n como sigue:
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check fun (x: Nat) =&gt; x + 5

#check Î» (x: Nat) =&gt; x + x
</pre>
</div>

<pre class="example">
fun x =&gt; x + 5 : Nat â†’ Nat
fun x =&gt; x + x : Nat â†’ Nat
</pre>


<p>
El tipo <code>Nat</code> se puede inferir en este ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check fun x =&gt; x + 5
#check Î» x =&gt; x + 5
</pre>
</div>

<pre class="example">
fun x =&gt; x + 5 : Nat â†’ Nat
fun x =&gt; x + 5 : Nat â†’ Nat
</pre>


<p>
Podemos evaluar una funciÃ³n lambda pasÃ¡ndole los parÃ¡metros que requiere
</p>

<div class="org-src-container">
<pre class="src src-lean4">#eval (Î» x: Nat =&gt; x + 5) 10
</pre>
</div>

<pre class="example">
15
</pre>


<p>
Crear una funciÃ³n a partir de otra expresiÃ³n es conocido como <b>abstracciÃ³n lambda</b>. Supongamos que tenemos una variable
<code>x: Î±</code> y podemos construir una expresiÃ³n <code>t: Î²</code>, entonces la expresiÃ³n <code>fun (x: Î±) =&gt; t</code> o, equivalentemente, <code>Î» x: Î± =&gt; t</code>,
es un objeto de tipo <code>Î± â†’ Î²</code>. AquÃ­ hay algunos ejemplos
</p>

<div class="org-src-container">
<pre class="src src-lean4">#check fun x: Nat =&gt; fun y: Bool =&gt; if not y then x + 1 else x +2
</pre>
</div>

<pre class="example">
fun x y =&gt; if (!y) = true then x + 1 else x + 2 : Nat â†’ Bool â†’ Nat
</pre>


<div class="org-src-container">
<pre class="src src-lean4">#check fun (x: Nat) (y: Bool) =&gt; if not y then x + 1 else x +2
</pre>
</div>

<pre class="example">
fun x y =&gt; if (!y) = true then x + 1 else x + 2 : Nat â†’ Bool â†’ Nat
</pre>


<div class="org-src-container">
<pre class="src src-lean4">#check fun x y =&gt; if not y then x + 1 else x + 2
</pre>
</div>

<pre class="example">
fun x y =&gt; if (!y) = true then x + 1 else x + 2 : Nat â†’ Bool â†’ Nat
</pre>


<p>
Lean interpreta los Ãºltimos tres ejemplos como la misma expresiÃ³n, en la Ãºltima, Lean infiere el tipo de <code>x</code> y de <code>y</code>
a partir de la expresiÃ³n.
</p>

<p>
Algunos ejemplos comunes de operaciones de funciones se pueden describir en tÃ©rminos de lambda abstracciÃ³n:
</p>

<div class="org-src-container">
<pre class="src src-lean4">def f (n: Nat): String := toString n
def g (s: String): Bool := s.length &gt; 0

#check fun x: Nat =&gt; x
#check fun x: Nat =&gt; true
#check fun x: Nat =&gt; g (f x)
#check fun x =&gt; g (f x)

</pre>
</div>

<pre class="example" id="org61c5c71">
fun x =&gt; x : Nat â†’ Nat
fun x =&gt; true : Nat â†’ Bool
fun x =&gt; g (f x) : Nat â†’ Bool
fun x =&gt; g (f x) : Nat â†’ Bool
fun x =&gt; x : Nat â†’ Nat
fun x =&gt; true : Nat â†’ Bool
fun x =&gt; g (f x) : Nat â†’ Bool
fun x =&gt; g (f x) : Nat â†’ Bool
</pre>
</div>
</div>
</div>
</body>
</html>
